/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: igris_c_msgs.idl
  Source: igris_c_msgs.hpp
  Cyclone DDS: v0.10.5

*****************************************************************/
#ifndef DDSCXX_IGRIS_C_MSGS_HPP
#define DDSCXX_IGRIS_C_MSGS_HPP

#include <array>
#include <cstdint>
#include <string>
#include <vector>

namespace igris_c {
namespace msg {
namespace dds {
const uint32_t N_JOINTS = 31;

enum class KinematicMode { MS, PJS };

class IMUState {
  private:
    std::array<float, 4> quaternion_    = {};
    std::array<float, 3> gyroscope_     = {};
    std::array<float, 3> accelerometer_ = {};
    std::array<float, 3> rpy_           = {};

  public:
    IMUState() = default;

    explicit IMUState(const std::array<float, 4> &quaternion, const std::array<float, 3> &gyroscope,
                      const std::array<float, 3> &accelerometer, const std::array<float, 3> &rpy)
        : quaternion_(quaternion), gyroscope_(gyroscope), accelerometer_(accelerometer), rpy_(rpy) {}

    const std::array<float, 4> &quaternion() const { return this->quaternion_; }
    std::array<float, 4> &quaternion() { return this->quaternion_; }
    void quaternion(const std::array<float, 4> &_val_) { this->quaternion_ = _val_; }
    void quaternion(std::array<float, 4> &&_val_) { this->quaternion_ = _val_; }
    const std::array<float, 3> &gyroscope() const { return this->gyroscope_; }
    std::array<float, 3> &gyroscope() { return this->gyroscope_; }
    void gyroscope(const std::array<float, 3> &_val_) { this->gyroscope_ = _val_; }
    void gyroscope(std::array<float, 3> &&_val_) { this->gyroscope_ = _val_; }
    const std::array<float, 3> &accelerometer() const { return this->accelerometer_; }
    std::array<float, 3> &accelerometer() { return this->accelerometer_; }
    void accelerometer(const std::array<float, 3> &_val_) { this->accelerometer_ = _val_; }
    void accelerometer(std::array<float, 3> &&_val_) { this->accelerometer_ = _val_; }
    const std::array<float, 3> &rpy() const { return this->rpy_; }
    std::array<float, 3> &rpy() { return this->rpy_; }
    void rpy(const std::array<float, 3> &_val_) { this->rpy_ = _val_; }
    void rpy(std::array<float, 3> &&_val_) { this->rpy_ = _val_; }

    bool operator==(const IMUState &_other) const {
        (void)_other;
        return quaternion_ == _other.quaternion_ && gyroscope_ == _other.gyroscope_ && accelerometer_ == _other.accelerometer_ &&
               rpy_ == _other.rpy_;
    }

    bool operator!=(const IMUState &_other) const { return !(*this == _other); }
};

class MotorCmd {
  private:
    uint16_t id_ = 0;
    float q_     = 0.0f;
    float dq_    = 0.0f;
    float tau_   = 0.0f;
    float kp_    = 0.0f;
    float kd_    = 0.0f;

  public:
    MotorCmd() = default;

    explicit MotorCmd(uint16_t id, float q, float dq, float tau, float kp, float kd)
        : id_(id), q_(q), dq_(dq), tau_(tau), kp_(kp), kd_(kd) {}

    uint16_t id() const { return this->id_; }
    uint16_t &id() { return this->id_; }
    void id(uint16_t _val_) { this->id_ = _val_; }
    float q() const { return this->q_; }
    float &q() { return this->q_; }
    void q(float _val_) { this->q_ = _val_; }
    float dq() const { return this->dq_; }
    float &dq() { return this->dq_; }
    void dq(float _val_) { this->dq_ = _val_; }
    float tau() const { return this->tau_; }
    float &tau() { return this->tau_; }
    void tau(float _val_) { this->tau_ = _val_; }
    float kp() const { return this->kp_; }
    float &kp() { return this->kp_; }
    void kp(float _val_) { this->kp_ = _val_; }
    float kd() const { return this->kd_; }
    float &kd() { return this->kd_; }
    void kd(float _val_) { this->kd_ = _val_; }

    bool operator==(const MotorCmd &_other) const {
        (void)_other;
        return id_ == _other.id_ && q_ == _other.q_ && dq_ == _other.dq_ && tau_ == _other.tau_ && kp_ == _other.kp_ && kd_ == _other.kd_;
    }

    bool operator!=(const MotorCmd &_other) const { return !(*this == _other); }
};

class LowCmd {
  private:
    ::igris_c::msg::dds::KinematicMode kinematic_mode_    = ::igris_c::msg::dds::KinematicMode::MS;
    std::array<::igris_c::msg::dds::MotorCmd, 31> motors_ = {};

  public:
    LowCmd() = default;

    explicit LowCmd(::igris_c::msg::dds::KinematicMode kinematic_mode, const std::array<::igris_c::msg::dds::MotorCmd, 31> &motors)
        : kinematic_mode_(kinematic_mode), motors_(motors) {}

    ::igris_c::msg::dds::KinematicMode kinematic_mode() const { return this->kinematic_mode_; }
    ::igris_c::msg::dds::KinematicMode &kinematic_mode() { return this->kinematic_mode_; }
    void kinematic_mode(::igris_c::msg::dds::KinematicMode _val_) { this->kinematic_mode_ = _val_; }
    const std::array<::igris_c::msg::dds::MotorCmd, 31> &motors() const { return this->motors_; }
    std::array<::igris_c::msg::dds::MotorCmd, 31> &motors() { return this->motors_; }
    void motors(const std::array<::igris_c::msg::dds::MotorCmd, 31> &_val_) { this->motors_ = _val_; }
    void motors(std::array<::igris_c::msg::dds::MotorCmd, 31> &&_val_) { this->motors_ = _val_; }

    bool operator==(const LowCmd &_other) const {
        (void)_other;
        return kinematic_mode_ == _other.kinematic_mode_ && motors_ == _other.motors_;
    }

    bool operator!=(const LowCmd &_other) const { return !(*this == _other); }
};

class HandCmd {
  private:
    std::vector<::igris_c::msg::dds::MotorCmd> motor_cmd_;

  public:
    HandCmd() = default;

    explicit HandCmd(const std::vector<::igris_c::msg::dds::MotorCmd> &motor_cmd) : motor_cmd_(motor_cmd) {}

    const std::vector<::igris_c::msg::dds::MotorCmd> &motor_cmd() const { return this->motor_cmd_; }
    std::vector<::igris_c::msg::dds::MotorCmd> &motor_cmd() { return this->motor_cmd_; }
    void motor_cmd(const std::vector<::igris_c::msg::dds::MotorCmd> &_val_) { this->motor_cmd_ = _val_; }
    void motor_cmd(std::vector<::igris_c::msg::dds::MotorCmd> &&_val_) { this->motor_cmd_ = _val_; }

    bool operator==(const HandCmd &_other) const {
        (void)_other;
        return motor_cmd_ == _other.motor_cmd_;
    }

    bool operator!=(const HandCmd &_other) const { return !(*this == _other); }
};

class MotorState {
  private:
    float q_              = 0.0f;
    float dq_             = 0.0f;
    float tau_est_        = 0.0f;
    int16_t temperature_  = 0;
    uint32_t status_bits_ = 0;

  public:
    MotorState() = default;

    explicit MotorState(float q, float dq, float tau_est, int16_t temperature, uint32_t status_bits)
        : q_(q), dq_(dq), tau_est_(tau_est), temperature_(temperature), status_bits_(status_bits) {}

    float q() const { return this->q_; }
    float &q() { return this->q_; }
    void q(float _val_) { this->q_ = _val_; }
    float dq() const { return this->dq_; }
    float &dq() { return this->dq_; }
    void dq(float _val_) { this->dq_ = _val_; }
    float tau_est() const { return this->tau_est_; }
    float &tau_est() { return this->tau_est_; }
    void tau_est(float _val_) { this->tau_est_ = _val_; }
    int16_t temperature() const { return this->temperature_; }
    int16_t &temperature() { return this->temperature_; }
    void temperature(int16_t _val_) { this->temperature_ = _val_; }
    uint32_t status_bits() const { return this->status_bits_; }
    uint32_t &status_bits() { return this->status_bits_; }
    void status_bits(uint32_t _val_) { this->status_bits_ = _val_; }

    bool operator==(const MotorState &_other) const {
        (void)_other;
        return q_ == _other.q_ && dq_ == _other.dq_ && tau_est_ == _other.tau_est_ && temperature_ == _other.temperature_ &&
               status_bits_ == _other.status_bits_;
    }

    bool operator!=(const MotorState &_other) const { return !(*this == _other); }
};

class JointState {
  private:
    float q_              = 0.0f;
    float dq_             = 0.0f;
    float tau_est_        = 0.0f;
    uint32_t status_bits_ = 0;

  public:
    JointState() = default;

    explicit JointState(float q, float dq, float tau_est, uint32_t status_bits)
        : q_(q), dq_(dq), tau_est_(tau_est), status_bits_(status_bits) {}

    float q() const { return this->q_; }
    float &q() { return this->q_; }
    void q(float _val_) { this->q_ = _val_; }
    float dq() const { return this->dq_; }
    float &dq() { return this->dq_; }
    void dq(float _val_) { this->dq_ = _val_; }
    float tau_est() const { return this->tau_est_; }
    float &tau_est() { return this->tau_est_; }
    void tau_est(float _val_) { this->tau_est_ = _val_; }
    uint32_t status_bits() const { return this->status_bits_; }
    uint32_t &status_bits() { return this->status_bits_; }
    void status_bits(uint32_t _val_) { this->status_bits_ = _val_; }

    bool operator==(const JointState &_other) const {
        (void)_other;
        return q_ == _other.q_ && dq_ == _other.dq_ && tau_est_ == _other.tau_est_ && status_bits_ == _other.status_bits_;
    }

    bool operator!=(const JointState &_other) const { return !(*this == _other); }
};

class LowState {
  private:
    uint32_t tick_ = 0;
    ::igris_c::msg::dds::IMUState imu_state_;
    std::array<::igris_c::msg::dds::MotorState, 31> motor_state_ = {};
    std::array<::igris_c::msg::dds::JointState, 31> joint_state_ = {};

  public:
    LowState() = default;

    explicit LowState(uint32_t tick, const ::igris_c::msg::dds::IMUState &imu_state,
                      const std::array<::igris_c::msg::dds::MotorState, 31> &motor_state,
                      const std::array<::igris_c::msg::dds::JointState, 31> &joint_state)
        : tick_(tick), imu_state_(imu_state), motor_state_(motor_state), joint_state_(joint_state) {}

    uint32_t tick() const { return this->tick_; }
    uint32_t &tick() { return this->tick_; }
    void tick(uint32_t _val_) { this->tick_ = _val_; }
    const ::igris_c::msg::dds::IMUState &imu_state() const { return this->imu_state_; }
    ::igris_c::msg::dds::IMUState &imu_state() { return this->imu_state_; }
    void imu_state(const ::igris_c::msg::dds::IMUState &_val_) { this->imu_state_ = _val_; }
    void imu_state(::igris_c::msg::dds::IMUState &&_val_) { this->imu_state_ = _val_; }
    const std::array<::igris_c::msg::dds::MotorState, 31> &motor_state() const { return this->motor_state_; }
    std::array<::igris_c::msg::dds::MotorState, 31> &motor_state() { return this->motor_state_; }
    void motor_state(const std::array<::igris_c::msg::dds::MotorState, 31> &_val_) { this->motor_state_ = _val_; }
    void motor_state(std::array<::igris_c::msg::dds::MotorState, 31> &&_val_) { this->motor_state_ = _val_; }
    const std::array<::igris_c::msg::dds::JointState, 31> &joint_state() const { return this->joint_state_; }
    std::array<::igris_c::msg::dds::JointState, 31> &joint_state() { return this->joint_state_; }
    void joint_state(const std::array<::igris_c::msg::dds::JointState, 31> &_val_) { this->joint_state_ = _val_; }
    void joint_state(std::array<::igris_c::msg::dds::JointState, 31> &&_val_) { this->joint_state_ = _val_; }

    bool operator==(const LowState &_other) const {
        (void)_other;
        return tick_ == _other.tick_ && imu_state_ == _other.imu_state_ && motor_state_ == _other.motor_state_ &&
               joint_state_ == _other.joint_state_;
    }

    bool operator!=(const LowState &_other) const { return !(*this == _other); }
};

class HandState {
  private:
    std::vector<::igris_c::msg::dds::MotorState> motor_state_;
    ::igris_c::msg::dds::IMUState imu_state_;

  public:
    HandState() = default;

    explicit HandState(const std::vector<::igris_c::msg::dds::MotorState> &motor_state, const ::igris_c::msg::dds::IMUState &imu_state)
        : motor_state_(motor_state), imu_state_(imu_state) {}

    const std::vector<::igris_c::msg::dds::MotorState> &motor_state() const { return this->motor_state_; }
    std::vector<::igris_c::msg::dds::MotorState> &motor_state() { return this->motor_state_; }
    void motor_state(const std::vector<::igris_c::msg::dds::MotorState> &_val_) { this->motor_state_ = _val_; }
    void motor_state(std::vector<::igris_c::msg::dds::MotorState> &&_val_) { this->motor_state_ = _val_; }
    const ::igris_c::msg::dds::IMUState &imu_state() const { return this->imu_state_; }
    ::igris_c::msg::dds::IMUState &imu_state() { return this->imu_state_; }
    void imu_state(const ::igris_c::msg::dds::IMUState &_val_) { this->imu_state_ = _val_; }
    void imu_state(::igris_c::msg::dds::IMUState &&_val_) { this->imu_state_ = _val_; }

    bool operator==(const HandState &_other) const {
        (void)_other;
        return motor_state_ == _other.motor_state_ && imu_state_ == _other.imu_state_;
    }

    bool operator!=(const HandState &_other) const { return !(*this == _other); }
};

enum class RelayState { RELAY_OFF, RELAY_ON };

enum class EStopState { ESTOP_RELEASED, ESTOP_PRESSED };

enum class BmsConnState { BMS_DISCONNECTED, BMS_CONNECTED };

enum class BmsInitState { BMS_NOT_INITIALIZED, BMS_INITIALIZED, MOTOR_INITIALIZED, BOTH_INITIALIZED };

class BmsState {
  private:
    uint32_t tick_                                    = 0;
    ::igris_c::msg::dds::RelayState body_power_       = ::igris_c::msg::dds::RelayState::RELAY_OFF;
    ::igris_c::msg::dds::RelayState legs_power_       = ::igris_c::msg::dds::RelayState::RELAY_OFF;
    ::igris_c::msg::dds::EStopState estop_            = ::igris_c::msg::dds::EStopState::ESTOP_RELEASED;
    ::igris_c::msg::dds::BmsConnState connect_        = ::igris_c::msg::dds::BmsConnState::BMS_DISCONNECTED;
    float battery_                                    = 0.0f;
    ::igris_c::msg::dds::BmsInitState bms_init_state_ = ::igris_c::msg::dds::BmsInitState::BMS_NOT_INITIALIZED;

  public:
    BmsState() = default;

    explicit BmsState(uint32_t tick, ::igris_c::msg::dds::RelayState body_power, ::igris_c::msg::dds::RelayState legs_power,
                      ::igris_c::msg::dds::EStopState estop, ::igris_c::msg::dds::BmsConnState connect, float battery,
                      ::igris_c::msg::dds::BmsInitState bms_init_state)
        : tick_(tick), body_power_(body_power), legs_power_(legs_power), estop_(estop), connect_(connect), battery_(battery),
          bms_init_state_(bms_init_state) {}

    uint32_t tick() const { return this->tick_; }
    uint32_t &tick() { return this->tick_; }
    void tick(uint32_t _val_) { this->tick_ = _val_; }
    ::igris_c::msg::dds::RelayState body_power() const { return this->body_power_; }
    ::igris_c::msg::dds::RelayState &body_power() { return this->body_power_; }
    void body_power(::igris_c::msg::dds::RelayState _val_) { this->body_power_ = _val_; }
    ::igris_c::msg::dds::RelayState legs_power() const { return this->legs_power_; }
    ::igris_c::msg::dds::RelayState &legs_power() { return this->legs_power_; }
    void legs_power(::igris_c::msg::dds::RelayState _val_) { this->legs_power_ = _val_; }
    ::igris_c::msg::dds::EStopState estop() const { return this->estop_; }
    ::igris_c::msg::dds::EStopState &estop() { return this->estop_; }
    void estop(::igris_c::msg::dds::EStopState _val_) { this->estop_ = _val_; }
    ::igris_c::msg::dds::BmsConnState connect() const { return this->connect_; }
    ::igris_c::msg::dds::BmsConnState &connect() { return this->connect_; }
    void connect(::igris_c::msg::dds::BmsConnState _val_) { this->connect_ = _val_; }
    float battery() const { return this->battery_; }
    float &battery() { return this->battery_; }
    void battery(float _val_) { this->battery_ = _val_; }
    ::igris_c::msg::dds::BmsInitState bms_init_state() const { return this->bms_init_state_; }
    ::igris_c::msg::dds::BmsInitState &bms_init_state() { return this->bms_init_state_; }
    void bms_init_state(::igris_c::msg::dds::BmsInitState _val_) { this->bms_init_state_ = _val_; }

    bool operator==(const BmsState &_other) const {
        (void)_other;
        return tick_ == _other.tick_ && body_power_ == _other.body_power_ && legs_power_ == _other.legs_power_ && estop_ == _other.estop_ &&
               connect_ == _other.connect_ && battery_ == _other.battery_ && bms_init_state_ == _other.bms_init_state_;
    }

    bool operator!=(const BmsState &_other) const { return !(*this == _other); }
};

enum class BmsInitType { BMS_INIT_NONE, BMS_INIT, MOTOR_INIT, BMS_AND_MOTOR_INIT, BMS_OFF };

class BmsInitCmd {
  private:
    std::string request_id_;
    ::igris_c::msg::dds::BmsInitType init_ = ::igris_c::msg::dds::BmsInitType::BMS_INIT_NONE;

  public:
    BmsInitCmd() = default;

    explicit BmsInitCmd(const std::string &request_id, ::igris_c::msg::dds::BmsInitType init) : request_id_(request_id), init_(init) {}

    const std::string &request_id() const { return this->request_id_; }
    std::string &request_id() { return this->request_id_; }
    void request_id(const std::string &_val_) { this->request_id_ = _val_; }
    void request_id(std::string &&_val_) { this->request_id_ = _val_; }
    ::igris_c::msg::dds::BmsInitType init() const { return this->init_; }
    ::igris_c::msg::dds::BmsInitType &init() { return this->init_; }
    void init(::igris_c::msg::dds::BmsInitType _val_) { this->init_ = _val_; }

    bool operator==(const BmsInitCmd &_other) const {
        (void)_other;
        return request_id_ == _other.request_id_ && init_ == _other.init_;
    }

    bool operator!=(const BmsInitCmd &_other) const { return !(*this == _other); }
};

enum class TorqueType { TORQUE_NONE, TORQUE_ON, TORQUE_OFF };

class TorqueCmd {
  private:
    std::string request_id_;
    ::igris_c::msg::dds::TorqueType torque_ = ::igris_c::msg::dds::TorqueType::TORQUE_NONE;

  public:
    TorqueCmd() = default;

    explicit TorqueCmd(const std::string &request_id, ::igris_c::msg::dds::TorqueType torque) : request_id_(request_id), torque_(torque) {}

    const std::string &request_id() const { return this->request_id_; }
    std::string &request_id() { return this->request_id_; }
    void request_id(const std::string &_val_) { this->request_id_ = _val_; }
    void request_id(std::string &&_val_) { this->request_id_ = _val_; }
    ::igris_c::msg::dds::TorqueType torque() const { return this->torque_; }
    ::igris_c::msg::dds::TorqueType &torque() { return this->torque_; }
    void torque(::igris_c::msg::dds::TorqueType _val_) { this->torque_ = _val_; }

    bool operator==(const TorqueCmd &_other) const {
        (void)_other;
        return request_id_ == _other.request_id_ && torque_ == _other.torque_;
    }

    bool operator!=(const TorqueCmd &_other) const { return !(*this == _other); }
};

enum class ControlMode { CONTROL_MODE_LOW_LEVEL, CONTROL_MODE_HIGH_LEVEL };

class ControlModeCmd {
  private:
    std::string request_id_;
    ::igris_c::msg::dds::ControlMode mode_ = ::igris_c::msg::dds::ControlMode::CONTROL_MODE_LOW_LEVEL;

  public:
    ControlModeCmd() = default;

    explicit ControlModeCmd(const std::string &request_id, ::igris_c::msg::dds::ControlMode mode) : request_id_(request_id), mode_(mode) {}

    const std::string &request_id() const { return this->request_id_; }
    std::string &request_id() { return this->request_id_; }
    void request_id(const std::string &_val_) { this->request_id_ = _val_; }
    void request_id(std::string &&_val_) { this->request_id_ = _val_; }
    ::igris_c::msg::dds::ControlMode mode() const { return this->mode_; }
    ::igris_c::msg::dds::ControlMode &mode() { return this->mode_; }
    void mode(::igris_c::msg::dds::ControlMode _val_) { this->mode_ = _val_; }

    bool operator==(const ControlModeCmd &_other) const {
        (void)_other;
        return request_id_ == _other.request_id_ && mode_ == _other.mode_;
    }

    bool operator!=(const ControlModeCmd &_other) const { return !(*this == _other); }
};

class ControlModeState {
  private:
    uint32_t tick_                         = 0;
    ::igris_c::msg::dds::ControlMode mode_ = ::igris_c::msg::dds::ControlMode::CONTROL_MODE_LOW_LEVEL;

  public:
    ControlModeState() = default;

    explicit ControlModeState(uint32_t tick, ::igris_c::msg::dds::ControlMode mode) : tick_(tick), mode_(mode) {}

    uint32_t tick() const { return this->tick_; }
    uint32_t &tick() { return this->tick_; }
    void tick(uint32_t _val_) { this->tick_ = _val_; }
    ::igris_c::msg::dds::ControlMode mode() const { return this->mode_; }
    ::igris_c::msg::dds::ControlMode &mode() { return this->mode_; }
    void mode(::igris_c::msg::dds::ControlMode _val_) { this->mode_ = _val_; }

    bool operator==(const ControlModeState &_other) const {
        (void)_other;
        return tick_ == _other.tick_ && mode_ == _other.mode_;
    }

    bool operator!=(const ControlModeState &_other) const { return !(*this == _other); }
};

class ServiceResponse {
  private:
    std::string request_id_;
    bool success_ = false;
    std::string message_;
    int32_t error_code_ = 0;

  public:
    ServiceResponse() = default;

    explicit ServiceResponse(const std::string &request_id, bool success, const std::string &message, int32_t error_code)
        : request_id_(request_id), success_(success), message_(message), error_code_(error_code) {}

    const std::string &request_id() const { return this->request_id_; }
    std::string &request_id() { return this->request_id_; }
    void request_id(const std::string &_val_) { this->request_id_ = _val_; }
    void request_id(std::string &&_val_) { this->request_id_ = _val_; }
    bool success() const { return this->success_; }
    bool &success() { return this->success_; }
    void success(bool _val_) { this->success_ = _val_; }
    const std::string &message() const { return this->message_; }
    std::string &message() { return this->message_; }
    void message(const std::string &_val_) { this->message_ = _val_; }
    void message(std::string &&_val_) { this->message_ = _val_; }
    int32_t error_code() const { return this->error_code_; }
    int32_t &error_code() { return this->error_code_; }
    void error_code(int32_t _val_) { this->error_code_ = _val_; }

    bool operator==(const ServiceResponse &_other) const {
        (void)_other;
        return request_id_ == _other.request_id_ && success_ == _other.success_ && message_ == _other.message_ &&
               error_code_ == _other.error_code_;
    }

    bool operator!=(const ServiceResponse &_other) const { return !(*this == _other); }
};

}  // namespace dds

}  // namespace msg

}  // namespace igris_c

#include "dds/topic/TopicTraits.hpp"
#include "org/eclipse/cyclonedds/topic/datatopic.hpp"

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::IMUState>::getTypeName() { return "igris_c::msg::dds::IMUState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::IMUState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::IMUState>::type_map_blob_sz() { return 442; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::IMUState>::type_info_blob_sz() { return 100; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::IMUState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x9a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24,
        0xaf, 0x00, 0x82, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x04, 0x09, 0x75, 0xb9, 0xaa, 0xa0, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x6b, 0x3b, 0x2d, 0x85, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x0e, 0x12, 0x75, 0x69, 0x00, 0x00,
        0x16, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09,
        0xb0, 0x7d, 0x92, 0xed, 0x00, 0x00, 0xee, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17,
        0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x49, 0x4d, 0x55, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x25, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x00,
        0x0b, 0x00, 0x00, 0x00, 0x71, 0x75, 0x61, 0x74, 0x65, 0x72, 0x6e, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00,
        0x0a, 0x00, 0x00, 0x00, 0x67, 0x79, 0x72, 0x6f, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x61, 0x63, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x72, 0x70, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec,
        0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf,
        0x24, 0xaf,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::IMUState>::type_info_blob() {
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0x00, 0x86, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1,
        0x51, 0x14, 0xd1, 0x00, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::MotorCmd>::getTypeName() { return "igris_c::msg::dds::MotorCmd"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::MotorCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::MotorCmd>::type_map_blob_sz() { return 402; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::MotorCmd>::type_info_blob_sz() { return 100; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::MotorCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0x8b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7,
        0x8c, 0x00, 0x73, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0xb8, 0x0b, 0xb7, 0x74, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x45, 0x80, 0xc2,
        0x74, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x26, 0xb5, 0x68, 0xe4, 0x00, 0x0b, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x87, 0x22, 0x16, 0x52, 0x00, 0xd5, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x8c,
        0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x00, 0xbd, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d,
        0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x43, 0x6d, 0x64, 0x00, 0x8d, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x00, 0x69, 0x64,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x71, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x74, 0x61, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x6b, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x6b, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x8c,
        0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1,
        0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::MotorCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x00, 0x77, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a,
        0xbb, 0x5c, 0x7d, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::LowCmd>::getTypeName() { return "igris_c::msg::dds::LowCmd"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::LowCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::LowCmd>::type_map_blob_sz() { return 962; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::LowCmd>::type_info_blob_sz() { return 196; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::LowCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0x4b, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf1, 0x8c, 0xb1, 0x99, 0x19, 0x70, 0x20, 0x52, 0xcd, 0xd4, 0x5d, 0x17, 0xf9, 0x9a,
        0x4a, 0x00, 0x5c, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x6e, 0x55, 0x1a, 0xa1, 0x4e, 0xcc, 0x32,
        0xf6, 0xcb, 0x52, 0x98, 0x8a, 0x7b, 0xdb, 0x16, 0x3a, 0x47, 0xfe, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x90, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1,
        0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x02, 0x5e, 0x1e, 0x92, 0xf1, 0x6e, 0x55, 0x1a, 0xa1, 0x4e, 0xcc, 0x32, 0xf6, 0xcb, 0x52, 0x98,
        0x8a, 0x7b, 0xdb, 0x00, 0x3a, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x66,
        0x3c, 0xae, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0xce, 0x4f, 0xb4,
        0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00,
        0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0xb8, 0x0b, 0xb7, 0x74, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc,
        0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x45, 0x80, 0xc2, 0x74, 0x00, 0x0b, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x26, 0xb5, 0x68, 0xe4, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x09, 0x87, 0x22, 0x16, 0x52, 0x00, 0x09, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf2, 0xeb, 0x50, 0x21, 0x2b, 0x4e, 0xb9, 0xbc,
        0x58, 0xe5, 0xa9, 0xf3, 0xb2, 0x88, 0xb0, 0x00, 0x99, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x4c, 0x6f, 0x77, 0x43, 0x6d, 0x64, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2d, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xe5, 0x7a, 0x95, 0x19, 0xc5, 0x83, 0x28, 0xf3, 0xa4, 0x14, 0x23, 0x80, 0xd9,
        0x2f, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x6b, 0x69, 0x6e, 0x65, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x6d, 0x6f, 0x64, 0x65,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf2, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x1f, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x07, 0x00,
        0x00, 0x00, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x73, 0x00, 0x00, 0x00, 0xf2, 0xe5, 0x7a, 0x95, 0x19, 0xc5, 0x83, 0x28, 0xf3, 0xa4, 0x14,
        0x23, 0x80, 0xd9, 0x2f, 0x72, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x29, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4b,
        0x69, 0x6e, 0x65, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x4d, 0x6f, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x4d, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x50, 0x4a, 0x53, 0x00, 0x00, 0x00, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0,
        0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x43, 0x6d, 0x64, 0x00, 0x8d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x11, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x00, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x11, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x12, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x70, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x6b, 0x64,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf2, 0xeb, 0x50, 0x21, 0x2b, 0x4e, 0xb9, 0xbc,
        0x58, 0xe5, 0xa9, 0xf3, 0xb2, 0x88, 0xb0, 0xf1, 0x8c, 0xb1, 0x99, 0x19, 0x70, 0x20, 0x52, 0xcd, 0xd4, 0x5d, 0x17, 0xf9, 0x9a, 0x4a,
        0xf2, 0xe5, 0x7a, 0x95, 0x19, 0xc5, 0x83, 0x28, 0xf3, 0xa4, 0x14, 0x23, 0x80, 0xd9, 0x2f, 0xf1, 0x6e, 0x55, 0x1a, 0xa1, 0x4e, 0xcc,
        0x32, 0xf6, 0xcb, 0x52, 0x98, 0x8a, 0x7b, 0xdb, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c,
        0x7d, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::LowCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0xc0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x8c,
        0xb1, 0x99, 0x19, 0x70, 0x20, 0x52, 0xcd, 0xd4, 0x5d, 0x17, 0xf9, 0x9a, 0x4a, 0x00, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x6e, 0x55, 0x1a, 0xa1, 0x4e, 0xcc, 0x32, 0xf6, 0xcb,
        0x52, 0x98, 0x8a, 0x7b, 0xdb, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c,
        0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x00, 0x77, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00,
        0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xeb, 0x50, 0x21, 0x2b, 0x4e, 0xb9, 0xbc, 0x58, 0xe5, 0xa9, 0xf3, 0xb2, 0x88, 0xb0, 0x00,
        0x9d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xe5,
        0x7a, 0x95, 0x19, 0xc5, 0x83, 0x28, 0xf3, 0xa4, 0x14, 0x23, 0x80, 0xd9, 0x2f, 0x00, 0x76, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x00, 0xc1, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::HandCmd>::getTypeName() { return "igris_c::msg::dds::HandCmd"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::HandCmd>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::HandCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::HandCmd>::type_map_blob_sz() { return 628; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::HandCmd>::type_info_blob_sz() { return 148; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::HandCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0xd7, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x33, 0x99, 0x40, 0xdd, 0xe0, 0x94, 0xd9, 0x62, 0xca, 0x29, 0x7b, 0xfc, 0x21,
        0xde, 0x00, 0x36, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xf1, 0x01, 0x00, 0x00, 0xf1, 0x1f, 0xab,
        0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x5b, 0xcf, 0x19, 0xa4, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6,
        0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x06, 0xb8, 0x0b, 0xb7, 0x74, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4,
        0xa6, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x45, 0x80, 0xc2, 0x74, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x09, 0x26, 0xb5, 0x68, 0xe4, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x87, 0x22, 0x16, 0x52, 0x00,
        0x4d, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xb2, 0x76, 0x04, 0x3a, 0xee, 0x31, 0xd7, 0xf1, 0x94, 0x9e, 0x2d, 0x36, 0x28,
        0x77, 0x00, 0x64, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
        0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x48, 0x61, 0x6e,
        0x64, 0x43, 0x6d, 0x64, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x80, 0xf2, 0x01, 0x00, 0x00, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d,
        0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6d, 0x64, 0x00, 0x00, 0x00, 0xf2, 0x8c, 0x33, 0x3c,
        0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x00, 0xbd, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67,
        0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x43, 0x6d, 0x64, 0x00, 0x8d, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x03, 0x00, 0x00, 0x00, 0x69, 0x64, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00,
        0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0x61,
        0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x6b, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x6b, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xb2, 0x76, 0x04,
        0x3a, 0xee, 0x31, 0xd7, 0xf1, 0x94, 0x9e, 0x2d, 0x36, 0x28, 0x77, 0xf1, 0x33, 0x99, 0x40, 0xdd, 0xe0, 0x94, 0xd9, 0x62, 0xca, 0x29,
        0x7b, 0xfc, 0x21, 0xde, 0xf2, 0x8c, 0x33, 0x3c, 0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0xf1, 0x1f, 0xab,
        0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd, 0x5e, 0x14, 0x80, 0xc7, 0x8c,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::HandCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x33,
        0x99, 0x40, 0xdd, 0xe0, 0x94, 0xd9, 0x62, 0xca, 0x29, 0x7b, 0xfc, 0x21, 0xde, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x1f, 0xab, 0x23, 0xbd, 0xa6, 0x53, 0x3c, 0xe1, 0xdd,
        0x5e, 0x14, 0x80, 0xc7, 0x8c, 0x00, 0x77, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0xf2, 0xb2, 0x76, 0x04, 0x3a, 0xee, 0x31, 0xd7, 0xf1, 0x94, 0x9e, 0x2d, 0x36, 0x28, 0x77, 0x00, 0x68, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x8c, 0x33, 0x3c,
        0x5c, 0x38, 0xff, 0xb3, 0xc6, 0xf0, 0x74, 0x4a, 0xbb, 0x5c, 0x7d, 0x00, 0xc1, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::MotorState>::getTypeName() { return "igris_c::msg::dds::MotorState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::MotorState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::MotorState>::type_map_blob_sz() { return 386; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::MotorState>::type_info_blob_sz() { return 100; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::MotorState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x7b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6,
        0x3b, 0x00, 0x63, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x8a, 0xf7, 0xae, 0xdf, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0xee, 0xf4, 0x38,
        0xf7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x97, 0x35, 0xa7, 0xc8, 0x00, 0xd6, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0xbe, 0x00,
        0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69,
        0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x53, 0x74,
        0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x5f, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0c, 0x00,
        0x00, 0x00, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0xf1, 0x93, 0x93,
        0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::MotorState>::type_info_blob() {
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0x00, 0x67, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34,
        0xa3, 0xf5, 0xdd, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::JointState>::getTypeName() { return "igris_c::msg::dds::JointState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::JointState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::JointState>::type_map_blob_sz() { return 338; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::JointState>::type_info_blob_sz() { return 100; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::JointState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x6b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4,
        0xbb, 0x00, 0x53, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x8a, 0xf7, 0xae, 0xdf, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x97, 0x35, 0xa7,
        0xc8, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85,
        0x94, 0x1f, 0x95, 0x00, 0x9e, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4a,
        0x6f, 0x69, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x5f, 0x65, 0x73, 0x74, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x5f, 0x62, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85, 0x94, 0x1f, 0x95, 0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26,
        0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::JointState>::type_info_blob() {
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb, 0x00, 0x57, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85,
        0x94, 0x1f, 0x95, 0x00, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::LowState>::getTypeName() { return "igris_c::msg::dds::LowState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::LowState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::LowState>::type_map_blob_sz() { return 1568; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::LowState>::type_info_blob_sz() { return 244; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::LowState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x23, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf1, 0x18, 0x9d, 0x9c, 0xed, 0xc1, 0x62, 0xd5, 0x4e, 0x75, 0xe9, 0x9f, 0x79, 0xbe,
        0xf3, 0x00, 0x94, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0xe5, 0xe5, 0xc0, 0x75, 0x00, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24,
        0xaf, 0x9e, 0x5f, 0x37, 0x13, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf1, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b,
        0xb2, 0x1e, 0x53, 0xdc, 0x24, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x1f, 0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb, 0xdc, 0x8a, 0x37, 0x5d,
        0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0x00, 0x82, 0x00, 0x00, 0x00, 0xf1, 0x51,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x09, 0x75, 0xb9, 0xaa, 0xa0,
        0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x03, 0x09, 0x6b, 0x3b, 0x2d, 0x85, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x0e, 0x12, 0x75, 0x69, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0xb0, 0x7d, 0x92, 0xed, 0xf1, 0x93, 0x93, 0x61,
        0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47,
        0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x8a, 0xf7, 0xae, 0xdf, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0xee, 0xf4, 0x38, 0xf7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x07, 0x97, 0x35, 0xa7, 0xc8, 0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb,
        0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x8a, 0xf7, 0xae, 0xdf, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x97, 0x35, 0xa7,
        0xc8, 0x00, 0x72, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf2, 0x19, 0x35, 0x92, 0x04, 0xa3, 0xd3, 0xad, 0x20, 0xd2, 0x95, 0xa0,
        0x7b, 0xa2, 0x59, 0x00, 0xe6, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4c,
        0x6f, 0x77, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x69, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00,
        0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x69, 0x6d, 0x75, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf2, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0xf2, 0x67, 0x91, 0x4d, 0x00,
        0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x0c, 0x00, 0x00, 0x00, 0x6d, 0x6f, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74,
        0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf2, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85, 0x94, 0x1f, 0x95,
        0x0c, 0x00, 0x00, 0x00, 0x6a, 0x6f, 0x69, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e,
        0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d,
        0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x49, 0x4d, 0x55, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0xa6, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x04, 0x09, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x71, 0x75, 0x61, 0x74, 0x65, 0x72, 0x6e, 0x69, 0x6f, 0x6e, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x67, 0x79, 0x72, 0x6f, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x00, 0x00, 0x00,
        0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00,
        0x1e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x72, 0x70, 0x79, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3,
        0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00,
        0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x5f,
        0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x0c, 0x00,
        0x00, 0x00, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x62, 0x69, 0x74,
        0x73, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85, 0x94, 0x1f, 0x95, 0x00, 0x00, 0x00,
        0x9e, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67,
        0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x4a, 0x6f, 0x69, 0x6e, 0x74,
        0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x5f, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x5f, 0x62, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xf2, 0x19, 0x35, 0x92,
        0x04, 0xa3, 0xd3, 0xad, 0x20, 0xd2, 0x95, 0xa0, 0x7b, 0xa2, 0x59, 0xf1, 0x18, 0x9d, 0x9c, 0xed, 0xc1, 0x62, 0xd5, 0x4e, 0x75, 0xe9,
        0x9f, 0x79, 0xbe, 0xf3, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0xf1, 0x69, 0xe4,
        0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3,
        0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0xf2, 0xc2,
        0x9b, 0xcf, 0x67, 0x27, 0xc7, 0x44, 0x6e, 0x8d, 0x1a, 0x85, 0x94, 0x1f, 0x95, 0xf1, 0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22,
        0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::LowState>::type_info_blob() {
    static const uint8_t blob[] = {
        0xf0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x70, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1,
        0x18, 0x9d, 0x9c, 0xed, 0xc1, 0x62, 0xd5, 0x4e, 0x75, 0xe9, 0x9f, 0x79, 0xbe, 0xf3, 0x00, 0x98, 0x00, 0x00, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3,
        0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0x00, 0x86, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x93, 0x93, 0x61,
        0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0x00, 0x67, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1,
        0x6d, 0x80, 0x69, 0x81, 0x2d, 0x26, 0x77, 0x22, 0x51, 0xe0, 0x1c, 0xd1, 0xa4, 0xbb, 0x00, 0x57, 0x00, 0x00, 0x00, 0x02, 0x10,
        0x00, 0x40, 0x70, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x19, 0x35, 0x92, 0x04, 0xa3, 0xd3,
        0xad, 0x20, 0xd2, 0x95, 0xa0, 0x7b, 0xa2, 0x59, 0x00, 0xea, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51,
        0x14, 0xd1, 0x00, 0xda, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3,
        0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xc2, 0x9b, 0xcf, 0x67, 0x27, 0xc7,
        0x44, 0x6e, 0x8d, 0x1a, 0x85, 0x94, 0x1f, 0x95, 0x00, 0xa2, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::HandState>::getTypeName() { return "igris_c::msg::dds::HandState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::HandState>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::HandState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::HandState>::type_map_blob_sz() { return 1110; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::HandState>::type_info_blob_sz() { return 196; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::HandState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x7a, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf1, 0x41, 0x80, 0x02, 0x32, 0x34, 0xb5, 0x8e, 0x30, 0x2a, 0x64, 0x90, 0xa4, 0x56,
        0xc6, 0x00, 0x55, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xf1, 0x01, 0x00, 0x00, 0xf1, 0x93, 0x93,
        0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0xb2, 0x1e, 0x53, 0xdc, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0x9e,
        0x5f, 0x37, 0x13, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1, 0xa6, 0x3b, 0x63, 0x00, 0x00, 0x00,
        0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x76, 0x94, 0xf4, 0xa6, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x09, 0x47, 0xbc, 0xdc, 0xd7, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x8a, 0xf7, 0xae,
        0xdf, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0xee, 0xf4, 0x38, 0xf7, 0x00, 0x0b, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x97, 0x35, 0xa7, 0xc8, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d,
        0x0b, 0xbf, 0x24, 0xaf, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x72, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x09, 0x75, 0xb9, 0xaa, 0xa0, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x6b, 0x3b, 0x2d, 0x85, 0x00, 0x00, 0x16, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x0e, 0x12,
        0x75, 0x69, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x03, 0x09, 0xb0, 0x7d, 0x92, 0xed, 0x00, 0x00, 0x6e, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf2, 0x6a, 0xd5, 0x1a,
        0x3a, 0x7e, 0x20, 0x18, 0x3e, 0x6c, 0xf9, 0x42, 0x91, 0x6f, 0xc2, 0x00, 0x98, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x25, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67,
        0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x48, 0x61, 0x6e, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xf2, 0x01, 0x00, 0x00, 0xf2,
        0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x6d, 0x6f,
        0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00, 0x00, 0x00, 0x0a, 0x00,
        0x00, 0x00, 0x69, 0x6d, 0x75, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69,
        0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0xbe, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x4d, 0x6f, 0x74, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00,
        0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x03, 0x00, 0x00, 0x00, 0x64, 0x71, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x61, 0x75, 0x5f,
        0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x0c, 0x00,
        0x00, 0x00, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x62, 0x69, 0x74,
        0x73, 0x00, 0x00, 0x00, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00, 0x00, 0x00,
        0xd6, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x69, 0x67,
        0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x49, 0x4d, 0x55, 0x53, 0x74,
        0x61, 0x74, 0x65, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x71, 0x75, 0x61, 0x74,
        0x65, 0x72, 0x6e, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x90, 0xf3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x67, 0x79, 0x72, 0x6f,
        0x73, 0x63, 0x6f, 0x70, 0x65, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x6f,
        0x6d, 0x65, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x90, 0xf3, 0x01, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x72, 0x70, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x5e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf2, 0x6a, 0xd5, 0x1a, 0x3a, 0x7e, 0x20, 0x18, 0x3e, 0x6c, 0xf9, 0x42, 0x91, 0x6f,
        0xc2, 0xf1, 0x41, 0x80, 0x02, 0x32, 0x34, 0xb5, 0x8e, 0x30, 0x2a, 0x64, 0x90, 0xa4, 0x56, 0xc6, 0xf2, 0x67, 0x91, 0x4d, 0x00, 0xf7,
        0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e, 0x47, 0x94, 0xa1,
        0xa6, 0x3b, 0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0xf1, 0x69, 0xe4, 0x7d, 0x30,
        0x02, 0xb3, 0xde, 0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::HandState>::type_info_blob() {
    static const uint8_t blob[] = {
        0xc0, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x41,
        0x80, 0x02, 0x32, 0x34, 0xb5, 0x8e, 0x30, 0x2a, 0x64, 0x90, 0xa4, 0x56, 0xc6, 0x00, 0x59, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x93, 0x93, 0x61, 0x3c, 0x26, 0xee, 0x63, 0x4c, 0x5e,
        0x47, 0x94, 0xa1, 0xa6, 0x3b, 0x00, 0x67, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x69, 0xe4, 0x7d, 0x30, 0x02, 0xb3, 0xde,
        0x8b, 0x03, 0x2d, 0x0b, 0xbf, 0x24, 0xaf, 0x00, 0x86, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x58, 0x00, 0x00, 0x00, 0x54, 0x00,
        0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x6a, 0xd5, 0x1a, 0x3a, 0x7e, 0x20, 0x18, 0x3e, 0x6c, 0xf9, 0x42, 0x91, 0x6f, 0xc2, 0x00,
        0x9c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x67,
        0x91, 0x4d, 0x00, 0xf7, 0xb5, 0x69, 0x62, 0xc3, 0x1a, 0x34, 0xa3, 0xf5, 0xdd, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf2, 0xe7, 0xdb, 0x2e, 0xc4, 0xec, 0x21, 0x17, 0x11, 0xef, 0x08, 0xf1, 0x51, 0x14, 0xd1, 0x00, 0xda, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::BmsState>::getTypeName() { return "igris_c::msg::dds::BmsState"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::BmsState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::BmsState>::type_map_blob_sz() { return 1798; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::BmsState>::type_info_blob_sz() { return 292; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::BmsState>::type_map_blob() {
    static const uint8_t blob[] = {
        0x4e, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xf1, 0xfb, 0x0a, 0x3e, 0x73, 0x98, 0x47, 0x91, 0x72, 0xfa, 0x72, 0x18, 0x71, 0xc5,
        0x6d, 0x00, 0xd1, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0xe5, 0xe5, 0xc0, 0x75, 0x00, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0xeb, 0xea, 0x85, 0x29, 0xb6, 0x84, 0x12, 0x34, 0xd0, 0xb4, 0xcb, 0x9a, 0xa6,
        0x9b, 0x49, 0xa6, 0xcd, 0xfe, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0xeb, 0xea, 0x85,
        0x29, 0xb6, 0x84, 0x12, 0x34, 0xd0, 0xb4, 0xcb, 0x9a, 0xa6, 0x9b, 0x7a, 0xb5, 0x76, 0x67, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x9a, 0x88, 0x80, 0x15, 0x53, 0xb0, 0xc6, 0xfe, 0x0a, 0x48, 0xfe, 0xdd, 0xae, 0x33, 0xf6,
        0x39, 0x23, 0xb9, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0xc3, 0xb6, 0xde, 0xb2, 0x0b,
        0x92, 0x01, 0x34, 0x19, 0x0c, 0x73, 0xdf, 0xdb, 0xe0, 0xb6, 0x40, 0xa0, 0xce, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x09, 0x20, 0xc1, 0xd1, 0x87, 0x00, 0x19, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0xa4,
        0x39, 0x2e, 0x11, 0xe3, 0x1e, 0x45, 0x5f, 0x74, 0x2d, 0x1f, 0x67, 0x0f, 0xc6, 0xa2, 0x05, 0x8e, 0x1c, 0xf1, 0xeb, 0xea, 0x85, 0x29,
        0xb6, 0x84, 0x12, 0x34, 0xd0, 0xb4, 0xcb, 0x9a, 0xa6, 0x9b, 0x3a, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xb3, 0x83, 0x1d, 0xb8, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x35, 0x07, 0x24, 0x49, 0xf1, 0x9a, 0x88, 0x80, 0x15, 0x53, 0xb0, 0xc6, 0xfe, 0x0a, 0x48, 0xfe, 0xdd, 0xae, 0x33, 0x00,
        0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xd6, 0x63, 0xf6,
        0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0x15, 0xcd, 0x1c, 0xf1, 0xc3,
        0xb6, 0xde, 0xb2, 0x0b, 0x92, 0x01, 0x34, 0x19, 0x0c, 0x73, 0xdf, 0xdb, 0xe0, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0xf1, 0x40,
        0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x99, 0x02, 0x77, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0xfa, 0x2e, 0x83, 0xf1, 0xa4, 0x39, 0x2e, 0x11, 0xe3, 0x1e, 0x45, 0x5f, 0x74,
        0x2d, 0x1f, 0x67, 0x0f, 0xc6, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00,
        0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xaa, 0x7d, 0x6b, 0xb4, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xc5, 0x53, 0xca, 0xd9, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x34,
        0x23, 0x98, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x17, 0xd0, 0xf4,
        0x00, 0x00, 0x0f, 0x04, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xf2, 0x65, 0xa6, 0x93, 0x14, 0x9b, 0xdb, 0x16, 0x1c, 0xa0, 0x6f, 0xca,
        0x77, 0x73, 0xd2, 0x00, 0x4d, 0x01, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x42,
        0x6d, 0x73, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x1d, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x69, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x6a, 0xec, 0x39, 0xab, 0x27, 0xe4, 0xc8, 0xca, 0xe4, 0xaf, 0xa6, 0xfd, 0x4d, 0x45, 0x00,
        0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x62, 0x6f, 0x64, 0x79, 0x5f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x29, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x6a, 0xec, 0x39, 0xab, 0x27, 0xe4, 0xc8, 0xca, 0xe4, 0xaf, 0xa6,
        0xfd, 0x4d, 0x45, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x6c, 0x65, 0x67, 0x73, 0x5f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x31, 0xbd, 0xff, 0x57, 0xe3, 0xa9, 0x05,
        0x16, 0x61, 0xae, 0xa1, 0xfc, 0xc1, 0x12, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x65, 0x73, 0x74, 0x6f, 0x70, 0x00, 0x00, 0x00,
        0x26, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x98, 0x07, 0xbd, 0x58, 0x92, 0x65, 0x5a, 0xdf, 0x0b, 0xaf, 0x7d,
        0x24, 0x6d, 0x13, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x16, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72,
        0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xbd, 0x0c, 0x5a, 0x15, 0x2d,
        0x9b, 0x28, 0x68, 0xc7, 0x39, 0x5d, 0x79, 0x36, 0x46, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x62, 0x6d, 0x73, 0x5f, 0x69, 0x6e,
        0x69, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0xf2, 0x6a, 0xec, 0x39, 0xab, 0x27, 0xe4, 0xc8, 0xca, 0xe4, 0xaf,
        0xa6, 0xfd, 0x4d, 0x45, 0x77, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x26, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1e, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x52,
        0x65, 0x6c, 0x61, 0x79, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1c, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x52, 0x45, 0x4c, 0x41,
        0x59, 0x5f, 0x4f, 0x46, 0x46, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x52, 0x45, 0x4c, 0x41, 0x59, 0x5f, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0xf2, 0x31, 0xbd, 0xff, 0x57,
        0xe3, 0xa9, 0x05, 0x16, 0x61, 0xae, 0xa1, 0xfc, 0xc1, 0x12, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x26, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67,
        0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x45, 0x53, 0x74, 0x6f, 0x70, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x50, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0f, 0x00, 0x00, 0x00, 0x45, 0x53, 0x54, 0x4f, 0x50, 0x5f, 0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x45, 0x53, 0x54, 0x4f, 0x50, 0x5f, 0x50, 0x52, 0x45, 0x53, 0x53, 0x45, 0x44, 0x00, 0x00, 0x00, 0xf2, 0x98, 0x07, 0xbd, 0x58, 0x92,
        0x65, 0x5a, 0xdf, 0x0b, 0xaf, 0x7d, 0x24, 0x6d, 0x13, 0x00, 0x84, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x28, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a,
        0x64, 0x64, 0x73, 0x3a, 0x3a, 0x42, 0x6d, 0x73, 0x43, 0x6f, 0x6e, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x50, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00,
        0x00, 0x00, 0x42, 0x4d, 0x53, 0x5f, 0x44, 0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x42, 0x4d,
        0x53, 0x5f, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x00, 0x00, 0x00, 0xf2, 0xbd, 0x0c, 0x5a, 0x15, 0x2d, 0x9b, 0x28,
        0x68, 0xc7, 0x39, 0x5d, 0x79, 0x36, 0x46, 0x00, 0xdb, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x28, 0x00, 0x00, 0x00, 0x20, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x42, 0x6d, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0xa7, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0x42, 0x4d, 0x53, 0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x49, 0x41, 0x4c, 0x49, 0x5a, 0x45, 0x44, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
        0x42, 0x4d, 0x53, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x49, 0x41, 0x4c, 0x49, 0x5a, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x4d, 0x4f, 0x54, 0x4f,
        0x52, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x49, 0x41, 0x4c, 0x49, 0x5a, 0x45, 0x44, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x42, 0x4f, 0x54, 0x48, 0x5f, 0x49, 0x4e, 0x49,
        0x54, 0x49, 0x41, 0x4c, 0x49, 0x5a, 0x45, 0x44, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xf2, 0x65,
        0xa6, 0x93, 0x14, 0x9b, 0xdb, 0x16, 0x1c, 0xa0, 0x6f, 0xca, 0x77, 0x73, 0xd2, 0xf1, 0xfb, 0x0a, 0x3e, 0x73, 0x98, 0x47, 0x91, 0x72,
        0xfa, 0x72, 0x18, 0x71, 0xc5, 0x6d, 0xf2, 0x6a, 0xec, 0x39, 0xab, 0x27, 0xe4, 0xc8, 0xca, 0xe4, 0xaf, 0xa6, 0xfd, 0x4d, 0x45, 0xf1,
        0xeb, 0xea, 0x85, 0x29, 0xb6, 0x84, 0x12, 0x34, 0xd0, 0xb4, 0xcb, 0x9a, 0xa6, 0x9b, 0xf2, 0x31, 0xbd, 0xff, 0x57, 0xe3, 0xa9, 0x05,
        0x16, 0x61, 0xae, 0xa1, 0xfc, 0xc1, 0x12, 0xf1, 0x9a, 0x88, 0x80, 0x15, 0x53, 0xb0, 0xc6, 0xfe, 0x0a, 0x48, 0xfe, 0xdd, 0xae, 0x33,
        0xf2, 0x98, 0x07, 0xbd, 0x58, 0x92, 0x65, 0x5a, 0xdf, 0x0b, 0xaf, 0x7d, 0x24, 0x6d, 0x13, 0xf1, 0xc3, 0xb6, 0xde, 0xb2, 0x0b, 0x92,
        0x01, 0x34, 0x19, 0x0c, 0x73, 0xdf, 0xdb, 0xe0, 0xf2, 0xbd, 0x0c, 0x5a, 0x15, 0x2d, 0x9b, 0x28, 0x68, 0xc7, 0x39, 0x5d, 0x79, 0x36,
        0x46, 0xf1, 0xa4, 0x39, 0x2e, 0x11, 0xe3, 0x1e, 0x45, 0x5f, 0x74, 0x2d, 0x1f, 0x67, 0x0f, 0xc6,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::BmsState>::type_info_blob() {
    static const uint8_t blob[] = {
        0x20, 0x01, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x88, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1,
        0xfb, 0x0a, 0x3e, 0x73, 0x98, 0x47, 0x91, 0x72, 0xfa, 0x72, 0x18, 0x71, 0xc5, 0x6d, 0x00, 0xd5, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0xeb, 0xea, 0x85, 0x29, 0xb6, 0x84,
        0x12, 0x34, 0xd0, 0xb4, 0xcb, 0x9a, 0xa6, 0x9b, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x9a, 0x88, 0x80,
        0x15, 0x53, 0xb0, 0xc6, 0xfe, 0x0a, 0x48, 0xfe, 0xdd, 0xae, 0x33, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1,
        0xc3, 0xb6, 0xde, 0xb2, 0x0b, 0x92, 0x01, 0x34, 0x19, 0x0c, 0x73, 0xdf, 0xdb, 0xe0, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x14, 0x00,
        0x00, 0x00, 0xf1, 0xa4, 0x39, 0x2e, 0x11, 0xe3, 0x1e, 0x45, 0x5f, 0x74, 0x2d, 0x1f, 0x67, 0x0f, 0xc6, 0x00, 0x66, 0x00, 0x00,
        0x00, 0x02, 0x10, 0x00, 0x40, 0x88, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x65, 0xa6, 0x93,
        0x14, 0x9b, 0xdb, 0x16, 0x1c, 0xa0, 0x6f, 0xca, 0x77, 0x73, 0xd2, 0x00, 0x51, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x6a, 0xec, 0x39, 0xab, 0x27, 0xe4, 0xc8, 0xca, 0xe4,
        0xaf, 0xa6, 0xfd, 0x4d, 0x45, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x31, 0xbd, 0xff, 0x57, 0xe3, 0xa9,
        0x05, 0x16, 0x61, 0xae, 0xa1, 0xfc, 0xc1, 0x12, 0x00, 0x88, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x98, 0x07, 0xbd,
        0x58, 0x92, 0x65, 0x5a, 0xdf, 0x0b, 0xaf, 0x7d, 0x24, 0x6d, 0x13, 0x00, 0x88, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2,
        0xbd, 0x0c, 0x5a, 0x15, 0x2d, 0x9b, 0x28, 0x68, 0xc7, 0x39, 0x5d, 0x79, 0x36, 0x46, 0x00, 0xdf, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::BmsInitCmd>::getTypeName() { return "igris_c::msg::dds::BmsInitCmd"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::BmsInitCmd>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::BmsInitCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::BmsInitCmd>::type_map_blob_sz() { return 712; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::BmsInitCmd>::type_info_blob_sz() { return 148; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::BmsInitCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0xe2, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x34, 0x9a, 0x04, 0xbb, 0x0a, 0x4a, 0xb0, 0xe6, 0x43, 0x79, 0xd3, 0x5f, 0x54,
        0xde, 0x00, 0x41, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf6, 0x8d, 0x2c, 0x36, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x93, 0xb3, 0xe1, 0x0f, 0x68, 0x6d, 0x92, 0x6a, 0x7a, 0xf3, 0xfb, 0x4d, 0x8e,
        0xa7, 0xe3, 0x7f, 0x01, 0x36, 0xf1, 0x93, 0xb3, 0xe1, 0x0f, 0x68, 0x6d, 0x92, 0x6a, 0x7a, 0xf3, 0xfb, 0x4d, 0x8e, 0xa7, 0x76, 0x00,
        0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x7e, 0x67, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x2e, 0xaa, 0xa3, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xab, 0x63, 0x0c, 0x11, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x21, 0x6e, 0x94, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x94, 0xee, 0x7d, 0x00, 0x00, 0x96, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xc1,
        0xca, 0x79, 0xf8, 0x92, 0x38, 0x52, 0x65, 0x7d, 0x6c, 0x1d, 0x28, 0x02, 0xee, 0x00, 0x7f, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00,
        0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d,
        0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x42, 0x6d, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x43, 0x6d, 0x64, 0x00, 0x00, 0x00,
        0x4b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x83, 0x63, 0xf4, 0x08, 0xfc, 0xf8, 0x45, 0x38, 0xfc, 0x57, 0xcc, 0x15, 0xa6, 0xa2, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00, 0x00, 0xf2, 0x83, 0x63, 0xf4, 0x08, 0xfc, 0xf8, 0x45, 0x38,
        0xfc, 0x57, 0xcc, 0x15, 0xa6, 0xa2, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x27, 0x00, 0x00, 0x00, 0x20, 0x00,
        0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64,
        0x73, 0x3a, 0x3a, 0x42, 0x6d, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x42, 0x4d, 0x53, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x42, 0x4d, 0x53, 0x5f, 0x49, 0x4e, 0x49, 0x54,
        0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,
        0x00, 0x00, 0x4d, 0x4f, 0x54, 0x4f, 0x52, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x42, 0x4d, 0x53, 0x5f, 0x41, 0x4e,
        0x44, 0x5f, 0x4d, 0x4f, 0x54, 0x4f, 0x52, 0x5f, 0x49, 0x4e, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x42, 0x4d, 0x53, 0x5f, 0x4f, 0x46,
        0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xc1, 0xca, 0x79, 0xf8, 0x92, 0x38, 0x52,
        0x65, 0x7d, 0x6c, 0x1d, 0x28, 0x02, 0xee, 0xf1, 0x34, 0x9a, 0x04, 0xbb, 0x0a, 0x4a, 0xb0, 0xe6, 0x43, 0x79, 0xd3, 0x5f, 0x54, 0xde,
        0xf2, 0x83, 0x63, 0xf4, 0x08, 0xfc, 0xf8, 0x45, 0x38, 0xfc, 0x57, 0xcc, 0x15, 0xa6, 0xa2, 0xf1, 0x93, 0xb3, 0xe1, 0x0f, 0x68, 0x6d,
        0x92, 0x6a, 0x7a, 0xf3, 0xfb, 0x4d, 0x8e, 0xa7,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::BmsInitCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x34,
        0x9a, 0x04, 0xbb, 0x0a, 0x4a, 0xb0, 0xe6, 0x43, 0x79, 0xd3, 0x5f, 0x54, 0xde, 0x00, 0x45, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x93, 0xb3, 0xe1, 0x0f, 0x68, 0x6d, 0x92, 0x6a, 0x7a,
        0xf3, 0xfb, 0x4d, 0x8e, 0xa7, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0xf2, 0xc1, 0xca, 0x79, 0xf8, 0x92, 0x38, 0x52, 0x65, 0x7d, 0x6c, 0x1d, 0x28, 0x02, 0xee, 0x00, 0x83, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x83, 0x63, 0xf4,
        0x08, 0xfc, 0xf8, 0x45, 0x38, 0xfc, 0x57, 0xcc, 0x15, 0xa6, 0xa2, 0x00, 0xee, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::TorqueCmd>::getTypeName() { return "igris_c::msg::dds::TorqueCmd"; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::TorqueCmd>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::TorqueCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::TorqueCmd>::type_map_blob_sz() { return 596; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::TorqueCmd>::type_info_blob_sz() { return 148; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::TorqueCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0xba, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x01, 0x67, 0xa0, 0xe5, 0x8d, 0x17, 0xfc, 0x0f, 0x28, 0xd5, 0x26, 0x36, 0x2b,
        0xa5, 0x00, 0x41, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf6, 0x8d, 0x2c, 0x36, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x08, 0x6d, 0x50, 0x1f, 0xae, 0xaa, 0x20, 0x54, 0xe2, 0xf3, 0xb7, 0xe0, 0xfd,
        0x4d, 0xe9, 0xee, 0x26, 0x51, 0xf1, 0x08, 0x6d, 0x50, 0x1f, 0xae, 0xaa, 0x20, 0x54, 0xe2, 0xf3, 0xb7, 0xe0, 0xfd, 0x4d, 0x4e, 0x00,
        0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x4d, 0xe6, 0x6b, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xac, 0x84, 0xfe, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x9b, 0xe1, 0xd9, 0x00, 0x00, 0x49, 0x01, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0xf2, 0x5c, 0x51, 0x86, 0xda, 0x0c, 0xaa, 0xbd, 0xb7, 0xc1, 0xd1, 0x7c, 0xdb, 0x9b, 0x8f, 0x00, 0x81, 0x00, 0x00, 0x00,
        0xf2, 0x51, 0x01, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f,
        0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x54, 0x6f, 0x72, 0x71, 0x75, 0x65, 0x43, 0x6d, 0x64,
        0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x70, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0xaa, 0x06, 0x95, 0x53, 0x06, 0x8f, 0xa6, 0x60, 0x83, 0xf7, 0x9c,
        0x2e, 0x30, 0xf9, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x74, 0x6f, 0x72, 0x71, 0x75, 0x65, 0x00, 0x00, 0x00, 0xf2, 0xaa, 0x06,
        0x95, 0x53, 0x06, 0x8f, 0xa6, 0x60, 0x83, 0xf7, 0x9c, 0x2e, 0x30, 0xf9, 0x9d, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x26, 0x00,
        0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67,
        0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x54, 0x6f, 0x72, 0x71, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0x00, 0x69, 0x00,
        0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0c, 0x00, 0x00, 0x00, 0x54, 0x4f, 0x52, 0x51, 0x55, 0x45, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x54, 0x4f, 0x52, 0x51,
        0x55, 0x45, 0x5f, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x54, 0x4f, 0x52, 0x51, 0x55, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0x5c, 0x51, 0x86, 0xda, 0x0c, 0xaa, 0xbd, 0xb7, 0xc1, 0xd1, 0x7c, 0xdb, 0x9b,
        0x8f, 0xf1, 0x01, 0x67, 0xa0, 0xe5, 0x8d, 0x17, 0xfc, 0x0f, 0x28, 0xd5, 0x26, 0x36, 0x2b, 0xa5, 0xf2, 0xaa, 0x06, 0x95, 0x53, 0x06,
        0x8f, 0xa6, 0x60, 0x83, 0xf7, 0x9c, 0x2e, 0x30, 0xf9, 0xf1, 0x08, 0x6d, 0x50, 0x1f, 0xae, 0xaa, 0x20, 0x54, 0xe2, 0xf3, 0xb7, 0xe0,
        0xfd, 0x4d,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::TorqueCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x01,
        0x67, 0xa0, 0xe5, 0x8d, 0x17, 0xfc, 0x0f, 0x28, 0xd5, 0x26, 0x36, 0x2b, 0xa5, 0x00, 0x45, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x08, 0x6d, 0x50, 0x1f, 0xae, 0xaa, 0x20, 0x54, 0xe2,
        0xf3, 0xb7, 0xe0, 0xfd, 0x4d, 0x00, 0x52, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0xf2, 0x5c, 0x51, 0x86, 0xda, 0x0c, 0xaa, 0xbd, 0xb7, 0xc1, 0xd1, 0x7c, 0xdb, 0x9b, 0x8f, 0x00, 0x85, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0xaa, 0x06, 0x95,
        0x53, 0x06, 0x8f, 0xa6, 0x60, 0x83, 0xf7, 0x9c, 0x2e, 0x30, 0xf9, 0x00, 0xa1, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::ControlModeCmd>::getTypeName() {
    return "igris_c::msg::dds::ControlModeCmd";
}

template <> constexpr bool TopicTraits<::igris_c::msg::dds::ControlModeCmd>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::ControlModeCmd>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ControlModeCmd>::type_map_blob_sz() { return 572; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ControlModeCmd>::type_info_blob_sz() { return 148; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ControlModeCmd>::type_map_blob() {
    static const uint8_t blob[] = {
        0xa6, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0x4e, 0x6d, 0xd8, 0x77, 0x33, 0x0f, 0xff, 0x03, 0xd4, 0x32, 0x59, 0xed, 0x96,
        0x51, 0x00, 0x41, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf6, 0x8d, 0x2c, 0x36, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90,
        0x93, 0x15, 0xd6, 0x17, 0x12, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90, 0x93, 0x3a, 0x00,
        0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x6e, 0x69, 0x1b, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x9a, 0x7b, 0xbf, 0x00, 0x00, 0x46, 0x01, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0xf2, 0xb0, 0xf9, 0xba, 0x98, 0xa5, 0x97, 0x58, 0x50, 0x85, 0xe2, 0xbf, 0x34, 0x2e, 0x41, 0x00, 0x83, 0x00,
        0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69,
        0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
        0x4d, 0x6f, 0x64, 0x65, 0x43, 0x6d, 0x64, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x69, 0x64,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae,
        0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x6d, 0x6f, 0x64, 0x65, 0x00, 0x00,
        0x00, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae, 0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00,
        0xf2, 0x40, 0x01, 0x00, 0x27, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f,
        0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4d, 0x6f,
        0x64, 0x65, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x5f, 0x4d, 0x4f, 0x44, 0x45,
        0x5f, 0x4c, 0x4f, 0x57, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x5f,
        0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x48, 0x49, 0x47, 0x48, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xb0, 0xf9, 0xba, 0x98, 0xa5, 0x97, 0x58, 0x50, 0x85, 0xe2, 0xbf, 0x34, 0x2e, 0x41, 0xf1,
        0x4e, 0x6d, 0xd8, 0x77, 0x33, 0x0f, 0xff, 0x03, 0xd4, 0x32, 0x59, 0xed, 0x96, 0x51, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae, 0x0d, 0x75,
        0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90, 0x93,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ControlModeCmd>::type_info_blob() {
    static const uint8_t blob[] = {
        0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x4e,
        0x6d, 0xd8, 0x77, 0x33, 0x0f, 0xff, 0x03, 0xd4, 0x32, 0x59, 0xed, 0x96, 0x51, 0x00, 0x45, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98,
        0xf0, 0x00, 0x55, 0x90, 0x93, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0xf2, 0xb0, 0xf9, 0xba, 0x98, 0xa5, 0x97, 0x58, 0x50, 0x85, 0xe2, 0xbf, 0x34, 0x2e, 0x41, 0x00, 0x87, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x35, 0x8a, 0x72,
        0x99, 0xae, 0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0x00, 0x9a, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::ControlModeState>::getTypeName() {
    return "igris_c::msg::dds::ControlModeState";
}

template <> constexpr bool TopicTraits<::igris_c::msg::dds::ControlModeState>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ControlModeState>::type_map_blob_sz() { return 564; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ControlModeState>::type_info_blob_sz() { return 148; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ControlModeState>::type_map_blob() {
    static const uint8_t blob[] = {
        0xa6, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf1, 0xe2, 0x12, 0x29, 0x13, 0x58, 0x9a, 0x7e, 0x29, 0x9b, 0xbe, 0xfd, 0x82, 0x96,
        0x85, 0x00, 0x41, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0xe5, 0xe5, 0xc0, 0x75, 0x00, 0x19, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90,
        0x93, 0x15, 0xd6, 0x17, 0x12, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90, 0x93, 0x3a, 0x00,
        0x00, 0x00, 0xf1, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x6e, 0x69, 0x1b, 0x00, 0x00, 0x0e, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x9a, 0x7b, 0xbf, 0x00, 0x00, 0x3e, 0x01, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0xf2, 0xc4, 0x17, 0xac, 0xb6, 0x4d, 0x25, 0x15, 0x15, 0xbf, 0x33, 0xe2, 0x59, 0x14, 0xb4, 0x00, 0x7b, 0x00,
        0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69,
        0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
        0x4d, 0x6f, 0x64, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x69, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae, 0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a,
        0x68, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x6d, 0x6f, 0x64, 0x65, 0x00, 0x00, 0x00, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae, 0x0d,
        0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xf2, 0x40, 0x01, 0x00, 0x27, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a,
        0x64, 0x64, 0x73, 0x3a, 0x3a, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x4d, 0x6f, 0x64, 0x65, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00,
        0x00, 0x00, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x4c, 0x4f, 0x57, 0x5f, 0x4c, 0x45, 0x56,
        0x45, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x5f, 0x48, 0x49, 0x47,
        0x48, 0x5f, 0x4c, 0x45, 0x56, 0x45, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xf2, 0xc4,
        0x17, 0xac, 0xb6, 0x4d, 0x25, 0x15, 0x15, 0xbf, 0x33, 0xe2, 0x59, 0x14, 0xb4, 0xf1, 0xe2, 0x12, 0x29, 0x13, 0x58, 0x9a, 0x7e, 0x29,
        0x9b, 0xbe, 0xfd, 0x82, 0x96, 0x85, 0xf2, 0x35, 0x8a, 0x72, 0x99, 0xae, 0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0xf1,
        0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98, 0xf0, 0x00, 0x55, 0x90, 0x93,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ControlModeState>::type_info_blob() {
    static const uint8_t blob[] = {
        0x90, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0xe2,
        0x12, 0x29, 0x13, 0x58, 0x9a, 0x7e, 0x29, 0x9b, 0xbe, 0xfd, 0x82, 0x96, 0x85, 0x00, 0x45, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf1, 0x29, 0x33, 0x07, 0x9d, 0x2d, 0x83, 0x19, 0xf0, 0x98,
        0xf0, 0x00, 0x55, 0x90, 0x93, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0xf2, 0xc4, 0x17, 0xac, 0xb6, 0x4d, 0x25, 0x15, 0x15, 0xbf, 0x33, 0xe2, 0x59, 0x14, 0xb4, 0x00, 0x7f, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x35, 0x8a, 0x72,
        0x99, 0xae, 0x0d, 0x75, 0xfa, 0xc1, 0x76, 0x1c, 0x26, 0x5a, 0x68, 0x00, 0x9a, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

template <> constexpr const char *TopicTraits<::igris_c::msg::dds::ServiceResponse>::getTypeName() {
    return "igris_c::msg::dds::ServiceResponse";
}

template <> constexpr bool TopicTraits<::igris_c::msg::dds::ServiceResponse>::isSelfContained() { return false; }

template <> constexpr bool TopicTraits<::igris_c::msg::dds::ServiceResponse>::isKeyless() { return true; }

#ifdef DDSCXX_HAS_TYPE_DISCOVERY
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ServiceResponse>::type_map_blob_sz() { return 358; }
template <> constexpr unsigned int TopicTraits<::igris_c::msg::dds::ServiceResponse>::type_info_blob_sz() { return 100; }
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ServiceResponse>::type_map_blob() {
    static const uint8_t blob[] = {
        0x6b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf1, 0x35, 0x50, 0xfc, 0x69, 0xb0, 0xd6, 0xa0, 0x4e, 0xe7, 0x64, 0x52, 0xf7, 0xe5,
        0x70, 0x00, 0x53, 0x00, 0x00, 0x00, 0xf1, 0x51, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0xf6, 0x8d, 0x2c, 0x36, 0x0b, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x26, 0x0c, 0xa9, 0xdd, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x70, 0x00, 0x78, 0xe7, 0x31, 0x02, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x8e, 0x95, 0xbd,
        0x42, 0x00, 0xc9, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x68, 0x10, 0xdc, 0x64, 0x7b, 0x7d, 0x17, 0xf7, 0x0f, 0xab, 0x07,
        0xed, 0xb8, 0xc6, 0x00, 0xb1, 0x00, 0x00, 0x00, 0xf2, 0x51, 0x01, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x00,
        0x00, 0x00, 0x69, 0x67, 0x72, 0x69, 0x73, 0x5f, 0x63, 0x3a, 0x3a, 0x6d, 0x73, 0x67, 0x3a, 0x3a, 0x64, 0x64, 0x73, 0x3a, 0x3a, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x72, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x5f, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x70, 0x00, 0x08, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x65, 0x72, 0x72, 0x6f,
        0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf2, 0x68,
        0x10, 0xdc, 0x64, 0x7b, 0x7d, 0x17, 0xf7, 0x0f, 0xab, 0x07, 0xed, 0xb8, 0xc6, 0xf1, 0x35, 0x50, 0xfc, 0x69, 0xb0, 0xd6, 0xa0, 0x4e,
        0xe7, 0x64, 0x52, 0xf7, 0xe5, 0x70,
    };
    return blob;
}
template <> inline const uint8_t *TopicTraits<::igris_c::msg::dds::ServiceResponse>::type_info_blob() {
    static const uint8_t blob[] = {
        0x60, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
        0xf1, 0x35, 0x50, 0xfc, 0x69, 0xb0, 0xd6, 0xa0, 0x4e, 0xe7, 0x64, 0x52, 0xf7, 0xe5, 0x70, 0x00, 0x57, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x40, 0x28, 0x00, 0x00, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0xf2, 0x68, 0x10, 0xdc, 0x64, 0x7b, 0x7d, 0x17, 0xf7, 0x0f, 0xab, 0x07,
        0xed, 0xb8, 0xc6, 0x00, 0xb5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    return blob;
}
#endif  // DDSCXX_HAS_TYPE_DISCOVERY

}  // namespace topic
}  // namespace cyclonedds
}  // namespace eclipse
}  // namespace org

namespace dds {
namespace topic {

template <> struct topic_type_name<::igris_c::msg::dds::IMUState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::IMUState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::MotorCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::MotorCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::LowCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::LowCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::HandCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::HandCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::MotorState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::MotorState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::JointState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::JointState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::LowState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::LowState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::HandState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::HandState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::BmsState> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::BmsState>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::BmsInitCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::BmsInitCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::TorqueCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::TorqueCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::ControlModeCmd> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::ControlModeCmd>::getTypeName(); }
};

template <> struct topic_type_name<::igris_c::msg::dds::ControlModeState> {
    static std::string value() {
        return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::ControlModeState>::getTypeName();
    }
};

template <> struct topic_type_name<::igris_c::msg::dds::ServiceResponse> {
    static std::string value() { return org::eclipse::cyclonedds::topic::TopicTraits<::igris_c::msg::dds::ServiceResponse>::getTypeName(); }
};

}  // namespace topic
}  // namespace dds

REGISTER_TOPIC_TYPE(::igris_c::msg::dds::IMUState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::MotorCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::LowCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::HandCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::MotorState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::JointState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::LowState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::HandState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::BmsState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::BmsInitCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::TorqueCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::ControlModeCmd)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::ControlModeState)
REGISTER_TOPIC_TYPE(::igris_c::msg::dds::ServiceResponse)

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace core {
namespace cdr {

template <>::igris_c::msg::dds::KinematicMode enum_conversion<::igris_c::msg::dds::KinematicMode>(uint32_t in);

template <> propvec &get_type_props<::igris_c::msg::dds::IMUState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::IMUState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!write(streamer, instance.quaternion()[0], instance.quaternion().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!write(streamer, instance.gyroscope()[0], instance.gyroscope().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!write(streamer, instance.accelerometer()[0], instance.accelerometer().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!write(streamer, instance.rpy()[0], instance.rpy().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::IMUState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::IMUState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::IMUState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!read(streamer, instance.quaternion()[0], instance.quaternion().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!read(streamer, instance.gyroscope()[0], instance.gyroscope().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!read(streamer, instance.accelerometer()[0], instance.accelerometer().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!read(streamer, instance.rpy()[0], instance.rpy().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::IMUState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::IMUState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::IMUState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!move(streamer, instance.quaternion()[0], instance.quaternion().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!move(streamer, instance.gyroscope()[0], instance.gyroscope().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!move(streamer, instance.accelerometer()[0], instance.accelerometer().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!move(streamer, instance.rpy()[0], instance.rpy().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::IMUState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::IMUState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::IMUState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!max(streamer, instance.quaternion()[0], instance.quaternion().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!max(streamer, instance.gyroscope()[0], instance.gyroscope().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!max(streamer, instance.accelerometer()[0], instance.accelerometer().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, true))
                return false;
            if (!max(streamer, instance.rpy()[0], instance.rpy().size()))
                return false;
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::IMUState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::IMUState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::MotorCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::MotorCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.id()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tau()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.kp()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.kd()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::MotorCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::MotorCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.id()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tau()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.kp()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.kd()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::MotorCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::MotorCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.id()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tau()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.kp()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.kd()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::MotorCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::MotorCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.id()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tau()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.kp()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.kd()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::MotorCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::LowCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::LowCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.kinematic_mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motors()) {  // array depth 1
                if (!write(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::LowCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::LowCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.kinematic_mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (auto &a_1 : instance.motors()) {  // array depth 1
                if (!read(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::LowCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::LowCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.kinematic_mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motors()) {  // array depth 1
                if (!move(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::LowCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::LowCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.kinematic_mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motors()) {  // array depth 1
                if (!max(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::LowCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::HandCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::HandCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_cmd().size());
                if (!write(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!write(streamer, instance.motor_cmd()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::HandCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::HandCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_cmd().size());
                if (!read(streamer, se_1))
                    return false;
                instance.motor_cmd().resize(se_1);
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!read(streamer, instance.motor_cmd()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::HandCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::HandCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_cmd().size());
                if (!move(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!move(streamer, instance.motor_cmd()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::HandCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::HandCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = 0;
                if (!max(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!max(streamer, instance.motor_cmd()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            streamer.position(SIZE_MAX);
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::HandCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::MotorState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::MotorState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.temperature()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::MotorState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::MotorState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.temperature()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::MotorState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::MotorState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.temperature()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::MotorState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::MotorState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.temperature()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::MotorState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::MotorState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::JointState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::JointState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::JointState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::JointState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::JointState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::JointState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::JointState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::JointState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::JointState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::JointState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::JointState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.q()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.dq()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tau_est()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.status_bits()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::JointState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::JointState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::LowState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::LowState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motor_state()) {  // array depth 1
                if (!write(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.joint_state()) {  // array depth 1
                if (!write(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::LowState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::LowState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (auto &a_1 : instance.motor_state()) {  // array depth 1
                if (!read(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (auto &a_1 : instance.joint_state()) {  // array depth 1
                if (!read(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::LowState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::LowState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motor_state()) {  // array depth 1
                if (!move(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.joint_state()) {  // array depth 1
                if (!move(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::LowState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::LowState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.motor_state()) {  // array depth 1
                if (!max(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(true, false))
                return false;
            for (const auto &a_1 : instance.joint_state()) {  // array depth 1
                if (!max(streamer, a_1, prop))
                    return false;
            }  // array depth 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::LowState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::LowState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::HandState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::HandState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_state().size());
                if (!write(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!write(streamer, instance.motor_state()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::HandState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::HandState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_state().size());
                if (!read(streamer, se_1))
                    return false;
                instance.motor_state().resize(se_1);
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!read(streamer, instance.motor_state()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::HandState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::HandState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = uint32_t(instance.motor_state().size());
                if (!move(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!move(streamer, instance.motor_state()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::HandState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::HandState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!streamer.start_consecutive(false, false))
                return false;
            {
                uint32_t se_1 = 0;
                if (!max(streamer, se_1))
                    return false;
                for (uint32_t i_1 = 0; i_1 < se_1; i_1++) {
                    if (!max(streamer, instance.motor_state()[i_1], prop))
                        return false;
                }  // i_1
            }  // end sequence 1
            if (!streamer.finish_consecutive())
                return false;
            streamer.position(SIZE_MAX);
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.imu_state(), prop))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::HandState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::HandState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <>::igris_c::msg::dds::RelayState enum_conversion<::igris_c::msg::dds::RelayState>(uint32_t in);

template <>::igris_c::msg::dds::EStopState enum_conversion<::igris_c::msg::dds::EStopState>(uint32_t in);

template <>::igris_c::msg::dds::BmsConnState enum_conversion<::igris_c::msg::dds::BmsConnState>(uint32_t in);

template <>::igris_c::msg::dds::BmsInitState enum_conversion<::igris_c::msg::dds::BmsInitState>(uint32_t in);

template <> propvec &get_type_props<::igris_c::msg::dds::BmsState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::BmsState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.body_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.legs_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.estop()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.connect()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.battery()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 6:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.bms_init_state()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::BmsState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::BmsState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.body_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.legs_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.estop()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.connect()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.battery()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 6:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.bms_init_state()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::BmsState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::BmsState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.body_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.legs_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.estop()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.connect()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.battery()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 6:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.bms_init_state()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::BmsState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::BmsState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.body_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.legs_power()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.estop()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 4:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.connect()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 5:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.battery()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 6:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.bms_init_state()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::BmsState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <>::igris_c::msg::dds::BmsInitType enum_conversion<::igris_c::msg::dds::BmsInitType>(uint32_t in);

template <> propvec &get_type_props<::igris_c::msg::dds::BmsInitCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::BmsInitCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.init()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::BmsInitCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsInitCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::BmsInitCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.init()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::BmsInitCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsInitCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::BmsInitCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.init()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::BmsInitCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsInitCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::BmsInitCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.init()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::BmsInitCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::BmsInitCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <>::igris_c::msg::dds::TorqueType enum_conversion<::igris_c::msg::dds::TorqueType>(uint32_t in);

template <> propvec &get_type_props<::igris_c::msg::dds::TorqueCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::TorqueCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.torque()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::TorqueCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::TorqueCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::TorqueCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.torque()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::TorqueCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::TorqueCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::TorqueCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.torque()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::TorqueCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::TorqueCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::TorqueCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.torque()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::TorqueCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::TorqueCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <>::igris_c::msg::dds::ControlMode enum_conversion<::igris_c::msg::dds::ControlMode>(uint32_t in);

template <> propvec &get_type_props<::igris_c::msg::dds::ControlModeCmd>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::ControlModeCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::ControlModeCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeCmd>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::ControlModeCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::ControlModeCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeCmd>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::ControlModeCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::ControlModeCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeCmd>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::ControlModeCmd &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::ControlModeCmd &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeCmd>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::ControlModeState>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::ControlModeState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::ControlModeState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeState>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::ControlModeState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::ControlModeState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeState>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::ControlModeState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::ControlModeState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeState>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::ControlModeState &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.tick()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.mode()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::ControlModeState &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ControlModeState>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

template <> propvec &get_type_props<::igris_c::msg::dds::ServiceResponse>();

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool write(T &streamer, const ::igris_c::msg::dds::ServiceResponse &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!write_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.success()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!write_string(streamer, instance.message(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!write(streamer, instance.error_code()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool write(S &str, const ::igris_c::msg::dds::ServiceResponse &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ServiceResponse>();
    str.set_mode(cdr_stream::stream_mode::write, as_key);
    return write(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool read(T &streamer, ::igris_c::msg::dds::ServiceResponse &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!read_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.success()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!read_string(streamer, instance.message(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!read(streamer, instance.error_code()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool read(S &str, ::igris_c::msg::dds::ServiceResponse &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ServiceResponse>();
    str.set_mode(cdr_stream::stream_mode::read, as_key);
    return read(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool move(T &streamer, const ::igris_c::msg::dds::ServiceResponse &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!move_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.success()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!move_string(streamer, instance.message(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!move(streamer, instance.error_code()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool move(S &str, const ::igris_c::msg::dds::ServiceResponse &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ServiceResponse>();
    str.set_mode(cdr_stream::stream_mode::move, as_key);
    return move(str, instance, props.data());
}

template <typename T, std::enable_if_t<std::is_base_of<cdr_stream, T>::value, bool> = true>
bool max(T &streamer, const ::igris_c::msg::dds::ServiceResponse &instance, entity_properties_t *props) {
    (void)instance;
    if (!streamer.start_struct(*props))
        return false;
    auto prop = streamer.first_entity(props);
    while (prop) {
        switch (prop->m_id) {
        case 0:
            if (!streamer.start_member(*prop))
                return false;
            if (!max_string(streamer, instance.request_id(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 1:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.success()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 2:
            if (!streamer.start_member(*prop))
                return false;
            if (!max_string(streamer, instance.message(), 0))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        case 3:
            if (!streamer.start_member(*prop))
                return false;
            if (!max(streamer, instance.error_code()))
                return false;
            if (!streamer.finish_member(*prop))
                return false;
            break;
        }
        prop = streamer.next_entity(prop);
    }
    return streamer.finish_struct(*props);
}

template <typename S, std::enable_if_t<std::is_base_of<cdr_stream, S>::value, bool> = true>
bool max(S &str, const ::igris_c::msg::dds::ServiceResponse &instance, bool as_key) {
    auto &props = get_type_props<::igris_c::msg::dds::ServiceResponse>();
    str.set_mode(cdr_stream::stream_mode::max, as_key);
    return max(str, instance, props.data());
}

}  // namespace cdr
}  // namespace core
}  // namespace cyclonedds
}  // namespace eclipse
}  // namespace org

#endif  // DDSCXX_IGRIS_C_MSGS_HPP
